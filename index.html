<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>

  <body>
    <script>
      // === ÐšÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚ Ð´Ð»Ñ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð¾Ð² ===
      AFRAME.registerComponent('apply-materials', {
        init: function () {
          const el = this.el;

          el.addEventListener('model-loaded', () => {
            const model = el.getObject3D('mesh');
            if (!model) {
              console.error('ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°!');
              return;
            }

            const envLoader = new THREE.CubeTextureLoader();
            envLoader.setPath('./');
            const envMap = envLoader.load([
              'posx.jpg', 'negx.jpg',
              'posy.jpg', 'negy.jpg',
              'posz.jpg', 'negz.jpg'
            ], () => {
              console.log('âœ… Environment map Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð°!');
            }, undefined, (error) => {
              console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ environment map:', error);
            });

            model.traverse((node) => {
              if (!node.isMesh || !node.material) return;

              const matName = node.material.name.toLowerCase();

              if (matName.includes('water')) {
                node.material = new THREE.MeshPhysicalMaterial({
                  color: 0xeeeeee,
                  metalness: 0,
                  roughness: 0.05,
                  transparent: true,
                  opacity: 0.4,
                  transmission: 0.7,
                  thickness: 0.2,
                  reflectivity: 0.8,
                  clearcoat: 0.3,
                  clearcoatRoughness: 0.05,
                  ior: 1.33,
                  envMap: envMap,
                  envMapIntensity: 1.6,
                  side: THREE.DoubleSide
                });
              } else if (matName.includes('ice')) {
                node.material = new THREE.MeshPhysicalMaterial({
                  color: 0xdaf6ff,
                  metalness: 0,
                  roughness: 0.1,
                  transmission: 0.95,
                  thickness: 0.6,
                  clearcoat: 1.0,
                  clearcoatRoughness: 0.05,
                  ior: 1.31,
                  envMap: envMap,
                  envMapIntensity: 1.5,
                  transparent: true,
                  opacity: 0.95,
                  side: THREE.DoubleSide
                });
              } else {
                node.material.envMap = envMap;
                node.material.envMapIntensity = 0.8;
                node.material.needsUpdate = true;
              }
            });

            console.log('âœ… ÐœÐ°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ñ‹ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ñ‹!');
            el.emit('materials-applied');
          });
        }
      });

      // === ÐšÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚ Ð´Ð»Ñ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ ===
      console.log('[soda] script tag loaded');

      AFRAME.registerComponent('float-animation', {
        schema: {
          names: { type: 'string', default: 'BubblesGlass,BubblesBottle,Orange_cake_with_jelly_OBJ' },
          amplitudes: { type: 'string', default: '0.1,0.1,0.015' }, // ÐžÐ´Ð¸Ð½ amplitude Ð½Ð° ÐºÐ°Ð¶Ð´Ñ‹Ð¹ name
          speeds: { type: 'string', default: '1.5,1.5,1.5' },      // ÐžÐ´Ð¸Ð½ speed Ð½Ð° ÐºÐ°Ð¶Ð´Ñ‹Ð¹ name
          axis: { type: 'string', default: 'y' },                 // 'x' | 'y' | 'z'
          randomPhase: { type: 'boolean', default: true }
        },

        init: function () {
          this.time = 0;
          this.targets = [];

          const ready = () => {
            const model = this.el.getObject3D('mesh');
            if (!model) return;

            this.targets.length = 0;

            const wanted = this.data.names.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
            const amplitudes = this.data.amplitudes.split(',').map(Number).filter(a => !isNaN(a));
            const speeds = this.data.speeds.split(',').map(Number).filter(s => !isNaN(s));

            if (amplitudes.length !== wanted.length || speeds.length !== wanted.length) {
              console.error('ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ amplitudes Ð¸ speeds Ð´Ð¾Ð»Ð¶Ð½Ð¾ ÑÐ¾Ð²Ð¿Ð°Ð´Ð°Ñ‚ÑŒ Ñ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾Ð¼ names!');
              return;
            }

            model.traverse((node) => {
              if (!node.isMesh) return;
              const nm = (node.name || '').toLowerCase();
              const index = wanted.findIndex(w => nm === w || nm.startsWith(w));
              if (index !== -1) {
                this.targets.push({
                  mesh: node,
                  base: node.position.clone(),
                  phase: this.data.randomPhase ? Math.random() * Math.PI * 2 : 0,
                  amplitude: amplitudes[index],
                  speed: speeds[index]
                });
                console.log('ðŸŽ¯ ÐÐ½Ð¸Ð¼Ð¸Ñ€ÑƒÑŽ Ð¼ÐµÑˆ:', node.name, 'Ñ amplitude:', amplitudes[index], 'speed:', speeds[index]);
              }
            });

            if (this.targets.length === 0) {
              console.warn('ÐÐµ Ð½Ð°ÑˆÑ‘Ð» Ñ†ÐµÐ»ÐµÐ²Ñ‹Ðµ Ð¼ÐµÑˆÐ¸ ÑÑ€ÐµÐ´Ð¸:', wanted);
            }
          };

          this.el.addEventListener('model-loaded', ready);
          this.el.addEventListener('materials-applied', ready);
        },

        tick: function (time, delta) {
          if (this.targets.length === 0) return;

          this.time += delta / 1000;
          const axis = this.data.axis.toLowerCase();

          this.targets.forEach(t => {
            const off = Math.sin(this.time * t.speed + t.phase) * t.amplitude;
            t.mesh.position.copy(t.base);
            if (axis === 'x') t.mesh.position.x = t.base.x + off;
            else if (axis === 'y') t.mesh.position.y = t.base.y + off;
            else if (axis === 'z') t.mesh.position.z = t.base.z + off;
            t.mesh.matrixWorldNeedsUpdate = true;
          });
        }
      });
    </script>

    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind"
      color-space="sRGB"
      renderer="colorManagement: true, physicallyCorrectLights: true, alpha: true, antialias: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-assets>
        <a-asset-item id="avatarModel" src="./AR-coctail.glb"></a-asset-item>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- ÐžÑÐ²ÐµÑ‰ÐµÐ½Ð¸Ðµ -->
      <a-light type="ambient" color="#ffffff" intensity="0.6"></a-light>
      <a-light type="directional" color="#ffffff" intensity="0.8" position="1 2 1"></a-light>
      <a-light type="point" color="#88ccff" intensity="0.6" position="-1 1 2"></a-light>

      <!-- ÐœÐ¾Ð´ÐµÐ»ÑŒ -->
      <a-entity mindar-image-target="targetIndex: 0">
        <a-gltf-model
          id="cocktailModel"
          src="#avatarModel"
          position="0 -0.2 0"
          scale="0.3 0.3 0.3"
          apply-materials
          float-animation="names: BubblesGlass,BubblesBottle,Orange_cake_with_jelly_OBJ; amplitudes: 0.1,0.1,0.015; speeds: 1.5,1.5,1.5; axis: y"
        ></a-gltf-model>
      </a-entity>

      <!-- Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ñ‚ÐµÐºÑÑ‚ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ñ‚Ñ€ÐµÐºÐ¸Ð½Ð³Ð° -->
      <a-text value="Ð¢Ñ€ÐµÐºÐ¸Ð½Ð³ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚?" position="0 0.2 0" color="red" scale="0.5 0.5 0.5"></a-text>
    </a-scene>
  </body>
</html>