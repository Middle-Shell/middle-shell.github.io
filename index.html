<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>

  <body>
    <script>
      // === Компонент для материалов ===
      AFRAME.registerComponent('apply-materials', {
        init: function () {
          const el = this.el;

          el.addEventListener('model-loaded', () => {
            const model = el.getObject3D('mesh');
            if (!model) {
              console.error('Модель не найдена!');
              return;
            }

            const envLoader = new THREE.CubeTextureLoader();
            envLoader.setPath('./');
            const envMap = envLoader.load([
              'posx.jpg', 'negx.jpg',
              'posy.jpg', 'negy.jpg',
              'posz.jpg', 'negz.jpg'
            ], () => {
              console.log('✅ Environment map загружена!');
            }, undefined, (error) => {
              console.error('Ошибка загрузки environment map:', error);
            });

            model.traverse((node) => {
              if (!node.isMesh || !node.material) return;

              const matName = node.material.name.toLowerCase();

              if (matName.includes('water')) {
                node.material = new THREE.MeshPhysicalMaterial({
                  color: 0xeeeeee,
                  metalness: 0,
                  roughness: 0.05,
                  transparent: true,
                  opacity: 0.4,
                  transmission: 0.7,
                  thickness: 0.2,
                  reflectivity: 0.8,
                  clearcoat: 0.3,
                  clearcoatRoughness: 0.05,
                  ior: 1.33,
                  envMap: envMap,
                  envMapIntensity: 1.6,
                  side: THREE.DoubleSide
                });
              } else if (matName.includes('ice')) {
                node.material = new THREE.MeshPhysicalMaterial({
                  color: 0xdaf6ff,
                  metalness: 0,
                  roughness: 0.1,
                  transmission: 0.95,
                  thickness: 0.6,
                  clearcoat: 1.0,
                  clearcoatRoughness: 0.05,
                  ior: 1.31,
                  envMap: envMap,
                  envMapIntensity: 1.5,
                  transparent: true,
                  opacity: 0.95,
                  side: THREE.DoubleSide
                });
              } else {
                node.material.envMap = envMap;
                node.material.envMapIntensity = 0.8;
                node.material.needsUpdate = true;
              }
            });

            console.log('✅ Материалы применены!');
            el.emit('materials-applied');
          });
        }
      });

      // === Компонент для анимации движения ===
      console.log('[soda] script tag loaded');

      AFRAME.registerComponent('float-animation', {
        schema: {
          names: { type: 'string', default: 'BubblesGlass,BubblesBottle,Orange_cake_with_jelly_OBJ' },
          amplitudes: { type: 'string', default: '0.1,0.1,0.015' }, // Один amplitude на каждый name
          speeds: { type: 'string', default: '1.5,1.5,1.5' },      // Один speed на каждый name
          axis: { type: 'string', default: 'y' },                 // 'x' | 'y' | 'z'
          randomPhase: { type: 'boolean', default: true }
        },

        init: function () {
          this.time = 0;
          this.targets = [];

          const ready = () => {
            const model = this.el.getObject3D('mesh');
            if (!model) return;

            this.targets.length = 0;

            const wanted = this.data.names.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
            const amplitudes = this.data.amplitudes.split(',').map(Number).filter(a => !isNaN(a));
            const speeds = this.data.speeds.split(',').map(Number).filter(s => !isNaN(s));

            if (amplitudes.length !== wanted.length || speeds.length !== wanted.length) {
              console.error('Количество amplitudes и speeds должно совпадать с количеством names!');
              return;
            }

            model.traverse((node) => {
              if (!node.isMesh) return;
              const nm = (node.name || '').toLowerCase();
              const index = wanted.findIndex(w => nm === w || nm.startsWith(w));
              if (index !== -1) {
                this.targets.push({
                  mesh: node,
                  base: node.position.clone(),
                  phase: this.data.randomPhase ? Math.random() * Math.PI * 2 : 0,
                  amplitude: amplitudes[index],
                  speed: speeds[index]
                });
                console.log('🎯 Анимирую меш:', node.name, 'с amplitude:', amplitudes[index], 'speed:', speeds[index]);
              }
            });

            if (this.targets.length === 0) {
              console.warn('Не нашёл целевые меши среди:', wanted);
            }
          };

          this.el.addEventListener('model-loaded', ready);
          this.el.addEventListener('materials-applied', ready);
        },

        tick: function (time, delta) {
          if (this.targets.length === 0) return;

          this.time += delta / 1000;
          const axis = this.data.axis.toLowerCase();

          this.targets.forEach(t => {
            const off = Math.sin(this.time * t.speed + t.phase) * t.amplitude;
            t.mesh.position.copy(t.base);
            if (axis === 'x') t.mesh.position.x = t.base.x + off;
            else if (axis === 'y') t.mesh.position.y = t.base.y + off;
            else if (axis === 'z') t.mesh.position.z = t.base.z + off;
            t.mesh.matrixWorldNeedsUpdate = true;
          });
        }
      });
    </script>

    <a-scene
      mindar-image="imageTargetSrc: ./targets.mind"
      color-space="sRGB"
      renderer="colorManagement: true, physicallyCorrectLights: true, alpha: true, antialias: true"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >
      <a-assets>
        <a-asset-item id="avatarModel" src="./AR-coctail.glb"></a-asset-item>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- Освещение -->
      <a-light type="ambient" color="#ffffff" intensity="0.6"></a-light>
      <a-light type="directional" color="#ffffff" intensity="0.8" position="1 2 1"></a-light>
      <a-light type="point" color="#88ccff" intensity="0.6" position="-1 1 2"></a-light>

      <!-- Модель -->
      <a-entity mindar-image-target="targetIndex: 0">
        <a-gltf-model
          id="cocktailModel"
          src="#avatarModel"
          position="0 -0.2 0"
          scale="0.3 0.3 0.3"
          apply-materials
          float-animation="names: BubblesGlass,BubblesBottle,Orange_cake_with_jelly_OBJ; amplitudes: 0.1,0.1,0.015; speeds: 1.5,1.5,1.5; axis: y"
        ></a-gltf-model>
      </a-entity>

      <!-- Тестовый текст для проверки трекинга -->
      <a-text value="Трекинг работает?" position="0 0.2 0" color="red" scale="0.5 0.5 0.5"></a-text>
    </a-scene>
  </body>
</html>